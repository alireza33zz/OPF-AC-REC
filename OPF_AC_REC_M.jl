using JuMP
using Gurobi
using CSV
using DataFrames
using Crayons

# Define sets of Generators and Buses
G = [1, 4]  # Set of generators
B = 1:6     # Set of buses
# Define sets of transmission lines
NL = [(1, 2), (2, 5), (3, 4), (3, 6)]  # Set of normal transmission lines
SL = [(2, 3)]  # Set of transmission lines with switches
L = vcat(NL, SL)  # Set of all transmission lines

# Lines and Switches status
Line_state = vcat(ones(length(NL)), zeros(length(SL)))  # Use length instead of size

# Create a dictionary to map lines to their states
start_values = Dict(L[i] => Line_state[i] for i in 1:length(L))

# Base power unit is kW
# Cost coefficients for each generator (linear costs for simplicity)
c_g = Dict(1 => 20.0, 4 => 5.0)

# Generation limits (kW)
P_g_min = Dict(1 => 8, 4 => 8)  # Minimum generation limits
P_g_max = Dict(1 => 150.0, 4 => 150.0)  # Maximum generation limits

# Demand at each bus (kW)
P_d = Dict(1 => 0.0, 2 => 40.0, 3 => 20.0, 4 => 0.0, 5 => 30.0, 6 => 30.0)  # Power demand at each bus

# Line parameters
b_ij = Dict((1, 2) => 0.01, (2, 3) => 0.015, (2,5) => 0.01, (3, 4) => 0.01, (3, 6) => 0.01)  # Susceptance of each line
r_ij = Dict((1, 2) => 0.002, (2, 3) => 0.003, (2,5) => 0.002, (3, 4) => 0.002, (3, 6) => 0.002)  # Resistance of each line

# Power flow limits (kW)
S_ij_max = Dict((1, 2) => 80.0, (2, 3) => 80.0, (2,5) => 80, (3, 4) => 130.0, (3, 6) => 80)
BIG_M = 1000000
# Create the optimization model
model = Model(Gurobi.Optimizer)

# Decision variables
@variable(model, P_g[g in G] >= 0)              # Real power generated by each generator
@variable(model, Q_g[g in G] >= 0)              # Reactive power generated by each generator
@variable(model, V[b in B], upper_bound=1.1, lower_bound=0.9, start=1.0)  # Voltage magnitude squared at each bus (SOC relaxation)
@variable(model, θ[b in B], start = 0)           # Voltage angle at each bus
@variable(model, P_ij[l in L], start = 0)        # Real power flow on each line
@variable(model, Q_ij[l in L], start = 0)        # Reactive power flow on each line
@variable(model, z[(i, j) in L], Bin, start = start_values[(i, j)])   # Binary variable indicating line status (0: off, 1: on)

# Objective: Minimize the total generation cost
@objective(model, Min, sum(c_g[g] * P_g[g] for g in G))

# Reference bus (slack bus) constraints
@constraint(model, θ[1] == 0)  # Reference angle
@constraint(model, V[1] == 1)  # Reference voltage magnitude (at bus 1)

# Set normal lines as always closed
for (i, j) in NL
    @constraint(model, z[(i, j)] == 1)
end

# Nodal power balance constraints
@constraint(
    model,
    [i in B],
    sum(P_g[g] for g in G if g == i) - P_d[i] == sum(P_ij[(i, j)] for (i, j) in L if i == i) - sum(P_ij[(j, i)] for (j, i) in L if j == i)
)
@constraint(
    model,
    [i in B],
    sum(Q_g[g] for g in G if g == i) == sum(Q_ij[(i, j)] for (i, j) in L if i == i) - sum(Q_ij[(j, i)] for (j, i) in L if j == i)
)

# Generation limits
for g in G
    @constraint(model, P_g[g] <= P_g_max[g])
    @constraint(model, P_g[g] >= P_g_min[g])
end

# SOC relaxation for line flows and voltage magnitudes
for (i, j) in L
    @constraint(model, P_ij[(i, j)]^2 + Q_ij[(i, j)]^2 <= S_ij_max[(i, j)]^2 * z[(i, j)])
    
    # Voltage magnitude constraint with SOC relaxation
    @constraint(model, V[i] - 2*(r_ij[(i, j)]*P_ij[(i, j)] + b_ij[(i, j)]*Q_ij[(i, j)]) + (r_ij[(i, j)]^2 + b_ij[(i, j)]^2)*(P_ij[(i, j)]^2 + Q_ij[(i, j)]^2) <= V[j] + BIG_M*(1-z[(i, j)]))
end

# Solve the model
optimize!(model)

# Define Crayons for styling text
bold_green = Crayon(foreground = :green, bold = true)
bold_red = Crayon(foreground = :red, bold = true)

# Check the solution status and print results
if termination_status(model) == MOI.OPTIMAL
    println(bold_green("Optimal solution found!"))
    println("Objective Value:\n", objective_value(model))
    println("Generation Output:\n", join(value.(P_g), "\n"))
    println("Voltage Magnitudes:\n", join(value.(V), "\n"))
    println("Line Flows (P_ij):\n", join(value.(P_ij), "\n"))
    println("Line Status:\n", join(value.(z), "\n"))
else
    println(bold_red("The model did not find an optimal solution."))
end

# Save the results to a CSV file
results = DataFrame(Status = ["Optimal solution found!"], 
                    ObjectiveValue = [objective_value(model)], 
                    GenerationOutput = [join(value.(P_g))], 
                    VoltageMagnitudes = [join(value.(V))],
                    LineFlows = [join(value.(P_ij))],
                    LineStatus = [join(value.(z))])
CSV.write("optimization_results_AC_OPF.csv", results)
